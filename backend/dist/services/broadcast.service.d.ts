export declare class BroadcastService {
    createVideoHighlight(data: {
        matchId: string;
        ballId?: string;
        inningsId?: string;
        videoUrl: string;
        startTimestamp: number;
        endTimestamp?: number;
        title: string;
        description?: string;
        category: string;
        cameraAngle?: string;
    }): Promise<{
        category: string;
        id: string;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        description: string | null;
        inningsId: string | null;
        title: string;
        viewCount: number;
        shareCount: number;
        tags: string | null;
        ballId: string | null;
        videoUrl: string;
        videoProvider: string;
        videoId: string | null;
        thumbnailUrl: string | null;
        startTimestamp: number;
        endTimestamp: number | null;
        ballTimestamp: number | null;
        cameraAngle: string | null;
        cameraAngles: string | null;
        isAutoGenerated: boolean;
        autoGenReason: string | null;
    }>;
    getVideoHighlights(matchId: string, filters?: {
        category?: string;
        ballId?: string;
        inningsId?: string;
    }): Promise<({
        ball: {
            bowler: {
                name: string;
                id: string;
            };
            batsman: {
                name: string;
                id: string;
            };
        } & {
            id: string;
            createdAt: Date;
            commentary: string | null;
            overNumber: number;
            inningsId: string;
            bowlerId: string;
            ballNumber: number;
            runs: number;
            isWicket: boolean;
            wicketType: import(".prisma/client").$Enums.WicketType | null;
            isExtra: boolean;
            extraType: import(".prisma/client").$Enums.ExtraType | null;
            extraRuns: number;
            shotAngle: number | null;
            shotDistance: number | null;
            shotZone: string | null;
            pitchLine: string | null;
            pitchLength: string | null;
            pitchX: number | null;
            pitchY: number | null;
            ballSpeed: number | null;
            ballTrajectory: string | null;
            shotType: string | null;
            overId: string;
            batsmanId: string;
            dismissedPlayerId: string | null;
            wicketTakerId: string | null;
        };
    } & {
        category: string;
        id: string;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        description: string | null;
        inningsId: string | null;
        title: string;
        viewCount: number;
        shareCount: number;
        tags: string | null;
        ballId: string | null;
        videoUrl: string;
        videoProvider: string;
        videoId: string | null;
        thumbnailUrl: string | null;
        startTimestamp: number;
        endTimestamp: number | null;
        ballTimestamp: number | null;
        cameraAngle: string | null;
        cameraAngles: string | null;
        isAutoGenerated: boolean;
        autoGenReason: string | null;
    })[]>;
    linkBallToVideo(ballId: string, videoId: string, timestamp: number): Promise<{
        category: string;
        id: string;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        description: string | null;
        inningsId: string | null;
        title: string;
        viewCount: number;
        shareCount: number;
        tags: string | null;
        ballId: string | null;
        videoUrl: string;
        videoProvider: string;
        videoId: string | null;
        thumbnailUrl: string | null;
        startTimestamp: number;
        endTimestamp: number | null;
        ballTimestamp: number | null;
        cameraAngle: string | null;
        cameraAngles: string | null;
        isAutoGenerated: boolean;
        autoGenReason: string | null;
    }>;
    autoGenerateHighlights(matchId: string): Promise<{
        count: number;
        message: string;
    }>;
    setupLiveStream(matchId: string, streamConfig: {
        streamUrl: string;
        streamType?: string;
        provider: string;
        providerId?: string;
        embedCode?: string;
        hlsUrl?: string;
        dashUrl?: string;
    }): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.StreamStatus;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        streamUrl: string;
        streamType: string;
        hlsUrl: string | null;
        dashUrl: string | null;
        qualityLevels: string | null;
        provider: string;
        providerId: string | null;
        embedCode: string | null;
        startedAt: Date | null;
        endedAt: Date | null;
        streamDelay: number;
        lastSyncedAt: Date | null;
        chatEnabled: boolean;
        chatUrl: string | null;
        peakViewers: number;
        totalViews: number;
    }>;
    updateStreamStatus(matchId: string, status: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.StreamStatus;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        streamUrl: string;
        streamType: string;
        hlsUrl: string | null;
        dashUrl: string | null;
        qualityLevels: string | null;
        provider: string;
        providerId: string | null;
        embedCode: string | null;
        startedAt: Date | null;
        endedAt: Date | null;
        streamDelay: number;
        lastSyncedAt: Date | null;
        chatEnabled: boolean;
        chatUrl: string | null;
        peakViewers: number;
        totalViews: number;
    }>;
    getStreamInfo(matchId: string): Promise<{
        match: {
            id: string;
            status: import(".prisma/client").$Enums.MatchStatus;
            homeTeam: {
                name: string;
            };
            awayTeam: {
                name: string;
            };
        };
    } & {
        id: string;
        status: import(".prisma/client").$Enums.StreamStatus;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        streamUrl: string;
        streamType: string;
        hlsUrl: string | null;
        dashUrl: string | null;
        qualityLevels: string | null;
        provider: string;
        providerId: string | null;
        embedCode: string | null;
        startedAt: Date | null;
        endedAt: Date | null;
        streamDelay: number;
        lastSyncedAt: Date | null;
        chatEnabled: boolean;
        chatUrl: string | null;
        peakViewers: number;
        totalViews: number;
    }>;
    updateStreamAnalytics(matchId: string, viewers: number): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.StreamStatus;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        streamUrl: string;
        streamType: string;
        hlsUrl: string | null;
        dashUrl: string | null;
        qualityLevels: string | null;
        provider: string;
        providerId: string | null;
        embedCode: string | null;
        startedAt: Date | null;
        endedAt: Date | null;
        streamDelay: number;
        lastSyncedAt: Date | null;
        chatEnabled: boolean;
        chatUrl: string | null;
        peakViewers: number;
        totalViews: number;
    }>;
    generateMatchPodcast(matchId: string, options?: {
        voice?: string;
        includeSummary?: boolean;
    }): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.PodcastStatus;
        createdAt: Date;
        updatedAt: Date;
        keyMoments: string | null;
        matchId: string;
        description: string | null;
        summary: string | null;
        title: string;
        episodeNumber: number | null;
        seriesName: string | null;
        audioUrl: string;
        audioFormat: string;
        duration: number;
        fileSize: number | null;
        isTTS: boolean;
        ttsVoice: string | null;
        ttsProvider: string | null;
        transcript: string | null;
        chapters: string | null;
        generatedAt: Date | null;
        errorMessage: string | null;
        isPublished: boolean;
        publishedAt: Date | null;
        rssGuid: string | null;
        downloadCount: number;
        playCount: number;
    }>;
    getPodcastStatus(podcastId: string): Promise<{
        match: {
            venue: string;
            homeTeam: {
                name: string;
            };
            awayTeam: {
                name: string;
            };
        };
    } & {
        id: string;
        status: import(".prisma/client").$Enums.PodcastStatus;
        createdAt: Date;
        updatedAt: Date;
        keyMoments: string | null;
        matchId: string;
        description: string | null;
        summary: string | null;
        title: string;
        episodeNumber: number | null;
        seriesName: string | null;
        audioUrl: string;
        audioFormat: string;
        duration: number;
        fileSize: number | null;
        isTTS: boolean;
        ttsVoice: string | null;
        ttsProvider: string | null;
        transcript: string | null;
        chapters: string | null;
        generatedAt: Date | null;
        errorMessage: string | null;
        isPublished: boolean;
        publishedAt: Date | null;
        rssGuid: string | null;
        downloadCount: number;
        playCount: number;
    }>;
    publishPodcast(podcastId: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.PodcastStatus;
        createdAt: Date;
        updatedAt: Date;
        keyMoments: string | null;
        matchId: string;
        description: string | null;
        summary: string | null;
        title: string;
        episodeNumber: number | null;
        seriesName: string | null;
        audioUrl: string;
        audioFormat: string;
        duration: number;
        fileSize: number | null;
        isTTS: boolean;
        ttsVoice: string | null;
        ttsProvider: string | null;
        transcript: string | null;
        chapters: string | null;
        generatedAt: Date | null;
        errorMessage: string | null;
        isPublished: boolean;
        publishedAt: Date | null;
        rssGuid: string | null;
        downloadCount: number;
        playCount: number;
    }>;
    getMatchPodcasts(matchId: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.PodcastStatus;
        createdAt: Date;
        updatedAt: Date;
        keyMoments: string | null;
        matchId: string;
        description: string | null;
        summary: string | null;
        title: string;
        episodeNumber: number | null;
        seriesName: string | null;
        audioUrl: string;
        audioFormat: string;
        duration: number;
        fileSize: number | null;
        isTTS: boolean;
        ttsVoice: string | null;
        ttsProvider: string | null;
        transcript: string | null;
        chapters: string | null;
        generatedAt: Date | null;
        errorMessage: string | null;
        isPublished: boolean;
        publishedAt: Date | null;
        rssGuid: string | null;
        downloadCount: number;
        playCount: number;
    }[]>;
    getBroadcasterSettings(matchId: string): Promise<{
        id: string;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        userId: string | null;
        layout: string;
        theme: string;
        fontSize: number;
        enabledPanels: string;
        autoTalkingPoints: boolean;
        talkingPointsFreq: number;
        graphicsFormat: string;
        graphicsQuality: string;
        breakTimings: string | null;
        nextBreakAt: number | null;
        notifyWicket: boolean;
        notifyMilestone: boolean;
        notifyBreak: boolean;
    }>;
    updateBroadcasterSettings(matchId: string, updates: any): Promise<{
        id: string;
        createdAt: Date;
        updatedAt: Date;
        matchId: string;
        userId: string | null;
        layout: string;
        theme: string;
        fontSize: number;
        enabledPanels: string;
        autoTalkingPoints: boolean;
        talkingPointsFreq: number;
        graphicsFormat: string;
        graphicsQuality: string;
        breakTimings: string | null;
        nextBreakAt: number | null;
        notifyWicket: boolean;
        notifyMilestone: boolean;
        notifyBreak: boolean;
    }>;
    generateTalkingPoints(matchId: string, overNumber?: number): Promise<{
        priority: number;
        category: string;
        id: string;
        createdAt: Date;
        matchId: string;
        description: string;
        playerId: string | null;
        teamId: string | null;
        overNumber: number | null;
        stats: string | null;
        isAutoGenerated: boolean;
        autoGenReason: string | null;
        headline: string;
        details: string | null;
        comparison: string | null;
        isUsed: boolean;
        usedAt: Date | null;
    }[]>;
    getTalkingPoints(matchId: string): Promise<{
        priority: number;
        category: string;
        id: string;
        createdAt: Date;
        matchId: string;
        description: string;
        playerId: string | null;
        teamId: string | null;
        overNumber: number | null;
        stats: string | null;
        isAutoGenerated: boolean;
        autoGenReason: string | null;
        headline: string;
        details: string | null;
        comparison: string | null;
        isUsed: boolean;
        usedAt: Date | null;
    }[]>;
    markTalkingPointUsed(pointId: string): Promise<{
        priority: number;
        category: string;
        id: string;
        createdAt: Date;
        matchId: string;
        description: string;
        playerId: string | null;
        teamId: string | null;
        overNumber: number | null;
        stats: string | null;
        isAutoGenerated: boolean;
        autoGenReason: string | null;
        headline: string;
        details: string | null;
        comparison: string | null;
        isUsed: boolean;
        usedAt: Date | null;
    }>;
    private detectProvider;
    private extractVideoId;
    private calculateTimestamp;
    private generatePodcastScript;
    private generatePodcastSummary;
    private generateKeyMoments;
    private generateChapters;
}
export declare const broadcastService: BroadcastService;
//# sourceMappingURL=broadcast.service.d.ts.map