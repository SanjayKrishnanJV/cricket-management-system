"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadcastService = exports.BroadcastService = void 0;
const database_1 = __importDefault(require("../config/database"));
const errorHandler_1 = require("../middleware/errorHandler");
class BroadcastService {
    async createVideoHighlight(data) {
        const videoProvider = this.detectProvider(data.videoUrl);
        const videoId = this.extractVideoId(data.videoUrl);
        return await database_1.default.videoHighlight.create({
            data: {
                ...data,
                videoProvider,
                videoId,
            },
        });
    }
    async getVideoHighlights(matchId, filters) {
        return await database_1.default.videoHighlight.findMany({
            where: {
                matchId,
                ...(filters?.category && { category: filters.category }),
                ...(filters?.ballId && { ballId: filters.ballId }),
                ...(filters?.inningsId && { inningsId: filters.inningsId }),
            },
            include: {
                ball: {
                    include: {
                        batsman: { select: { id: true, name: true } },
                        bowler: { select: { id: true, name: true } },
                    },
                },
            },
            orderBy: { createdAt: 'desc' },
        });
    }
    async linkBallToVideo(ballId, videoId, timestamp) {
        const ball = await database_1.default.ball.findUnique({
            where: { id: ballId },
            include: { innings: { select: { matchId: true } } },
        });
        if (!ball) {
            throw new errorHandler_1.AppError('Ball not found', 404);
        }
        const video = await database_1.default.videoHighlight.findUnique({
            where: { id: videoId },
        });
        if (!video) {
            throw new errorHandler_1.AppError('Video not found', 404);
        }
        return await database_1.default.videoHighlight.update({
            where: { id: videoId },
            data: {
                ballId,
                ballTimestamp: timestamp,
            },
        });
    }
    async autoGenerateHighlights(matchId) {
        const match = await database_1.default.match.findUnique({
            where: { id: matchId },
            include: {
                innings: {
                    include: {
                        balls: {
                            where: {
                                OR: [
                                    { runs: { gte: 4 } },
                                    { isWicket: true },
                                ],
                            },
                            include: {
                                batsman: { select: { name: true } },
                                bowler: { select: { name: true } },
                            },
                        },
                    },
                },
                liveStream: true,
            },
        });
        if (!match) {
            throw new errorHandler_1.AppError('Match not found', 404);
        }
        if (!match.liveStream || !match.liveStream.streamUrl) {
            throw new errorHandler_1.AppError('No live stream configured for this match', 400);
        }
        const highlights = [];
        for (const innings of match.innings) {
            for (const ball of innings.balls) {
                const category = ball.isWicket
                    ? ball.runs === 0 ? 'wicket' : 'run_out'
                    : ball.runs === 6
                        ? 'six'
                        : 'boundary';
                const title = ball.isWicket
                    ? `Wicket: ${ball.batsman.name} dismissed`
                    : `${ball.runs} runs - ${ball.batsman.name}`;
                const description = ball.isWicket
                    ? `${ball.bowler.name} to ${ball.batsman.name}`
                    : `${ball.batsman.name} hits ${ball.runs} runs off ${ball.bowler.name}`;
                highlights.push({
                    matchId,
                    ballId: ball.id,
                    inningsId: innings.id,
                    videoUrl: match.liveStream.streamUrl,
                    videoProvider: this.detectProvider(match.liveStream.streamUrl),
                    videoId: this.extractVideoId(match.liveStream.streamUrl),
                    startTimestamp: this.calculateTimestamp(ball.overNumber, ball.ballNumber),
                    title,
                    description,
                    category,
                    isAutoGenerated: true,
                    autoGenReason: category,
                });
            }
        }
        if (highlights.length === 0) {
            return { count: 0, message: 'No highlights to generate' };
        }
        const result = await database_1.default.videoHighlight.createMany({
            data: highlights,
            skipDuplicates: true,
        });
        return {
            count: result.count,
            message: `Generated ${result.count} highlights`,
        };
    }
    async setupLiveStream(matchId, streamConfig) {
        const match = await database_1.default.match.findUnique({
            where: { id: matchId },
        });
        if (!match) {
            throw new errorHandler_1.AppError('Match not found', 404);
        }
        const existingStream = await database_1.default.liveStream.findUnique({
            where: { matchId },
        });
        if (existingStream) {
            throw new errorHandler_1.AppError('Live stream already configured for this match', 400);
        }
        return await database_1.default.liveStream.create({
            data: {
                matchId,
                ...streamConfig,
                status: 'SCHEDULED',
            },
        });
    }
    async updateStreamStatus(matchId, status) {
        const stream = await database_1.default.liveStream.findUnique({
            where: { matchId },
        });
        if (!stream) {
            throw new errorHandler_1.AppError('Live stream not found', 404);
        }
        const updateData = {
            status: status,
        };
        if (status === 'LIVE') {
            updateData.startedAt = new Date();
        }
        else if (status === 'ENDED') {
            updateData.endedAt = new Date();
        }
        return await database_1.default.liveStream.update({
            where: { matchId },
            data: updateData,
        });
    }
    async getStreamInfo(matchId) {
        const stream = await database_1.default.liveStream.findUnique({
            where: { matchId },
            include: {
                match: {
                    select: {
                        id: true,
                        homeTeam: { select: { name: true } },
                        awayTeam: { select: { name: true } },
                        status: true,
                    },
                },
            },
        });
        return stream;
    }
    async updateStreamAnalytics(matchId, viewers) {
        const stream = await database_1.default.liveStream.findUnique({
            where: { matchId },
        });
        if (!stream) {
            throw new errorHandler_1.AppError('Live stream not found', 404);
        }
        return await database_1.default.liveStream.update({
            where: { matchId },
            data: {
                totalViews: { increment: 1 },
                peakViewers: Math.max(stream.peakViewers, viewers),
                lastSyncedAt: new Date(),
            },
        });
    }
    async generateMatchPodcast(matchId, options) {
        const match = await database_1.default.match.findUnique({
            where: { id: matchId },
            include: {
                homeTeam: true,
                awayTeam: true,
                tournament: true,
                innings: {
                    include: {
                        battingPerformances: {
                            include: { player: true },
                            orderBy: { runs: 'desc' },
                            take: 3,
                        },
                        bowlingPerformances: {
                            include: { player: true },
                            orderBy: { wickets: 'desc' },
                            take: 3,
                        },
                    },
                },
            },
        });
        if (!match) {
            throw new errorHandler_1.AppError('Match not found', 404);
        }
        if (match.status !== 'COMPLETED') {
            throw new errorHandler_1.AppError('Cannot generate podcast for incomplete match', 400);
        }
        const script = this.generatePodcastScript(match);
        const summary = this.generatePodcastSummary(match);
        const keyMoments = this.generateKeyMoments(match);
        const chapters = this.generateChapters(match);
        const podcast = await database_1.default.matchPodcast.create({
            data: {
                matchId,
                title: `${match.homeTeam.name} vs ${match.awayTeam.name} - Match Recap`,
                description: `Full match summary and highlights from ${match.venue}`,
                seriesName: match.tournament?.name,
                status: 'PENDING',
                isTTS: true,
                ttsVoice: options?.voice || 'male-1',
                ttsProvider: 'aws-polly',
                audioUrl: '',
                audioFormat: 'mp3',
                duration: 0,
                transcript: script,
                summary,
                keyMoments: JSON.stringify(keyMoments),
                chapters: JSON.stringify(chapters),
            },
        });
        return podcast;
    }
    async getPodcastStatus(podcastId) {
        return await database_1.default.matchPodcast.findUnique({
            where: { id: podcastId },
            include: {
                match: {
                    select: {
                        homeTeam: { select: { name: true } },
                        awayTeam: { select: { name: true } },
                        venue: true,
                    },
                },
            },
        });
    }
    async publishPodcast(podcastId) {
        const podcast = await database_1.default.matchPodcast.findUnique({
            where: { id: podcastId },
        });
        if (!podcast) {
            throw new errorHandler_1.AppError('Podcast not found', 404);
        }
        if (podcast.status !== 'READY') {
            throw new errorHandler_1.AppError('Podcast is not ready for publishing', 400);
        }
        return await database_1.default.matchPodcast.update({
            where: { id: podcastId },
            data: {
                isPublished: true,
                publishedAt: new Date(),
                status: 'PUBLISHED',
                rssGuid: `podcast-${podcastId}`,
            },
        });
    }
    async getMatchPodcasts(matchId) {
        return await database_1.default.matchPodcast.findMany({
            where: { matchId },
            orderBy: { createdAt: 'desc' },
        });
    }
    async getBroadcasterSettings(matchId) {
        let settings = await database_1.default.broadcasterSettings.findUnique({
            where: { matchId },
        });
        if (!settings) {
            settings = await database_1.default.broadcasterSettings.create({
                data: { matchId },
            });
        }
        return settings;
    }
    async updateBroadcasterSettings(matchId, updates) {
        return await database_1.default.broadcasterSettings.upsert({
            where: { matchId },
            update: updates,
            create: {
                matchId,
                ...updates,
            },
        });
    }
    async generateTalkingPoints(matchId, overNumber) {
        const match = await database_1.default.match.findUnique({
            where: { id: matchId },
            include: {
                homeTeam: { select: { name: true } },
                awayTeam: { select: { name: true } },
                innings: {
                    where: { status: 'IN_PROGRESS' },
                    include: {
                        battingPerformances: {
                            include: { player: true },
                            orderBy: { runs: 'desc' },
                        },
                        bowlingPerformances: {
                            include: { player: true },
                            orderBy: { wickets: 'desc' },
                        },
                        balls: {
                            orderBy: { createdAt: 'desc' },
                            take: 50,
                        },
                    },
                },
            },
        });
        if (!match || !match.innings[0]) {
            return [];
        }
        const points = [];
        const innings = match.innings[0];
        const recentBalls = innings.balls.slice(0, 30);
        const partnershipRuns = recentBalls.reduce((sum, b) => sum + b.runs, 0);
        if (partnershipRuns >= 50) {
            points.push({
                matchId,
                category: 'milestone',
                priority: 8,
                headline: `${partnershipRuns}-run partnership`,
                description: `Current partnership has added ${partnershipRuns} runs in the last ${recentBalls.length} balls`,
                overNumber,
                isAutoGenerated: true,
                autoGenReason: 'partnership_milestone',
            });
        }
        const topBatsman = innings.battingPerformances[0];
        if (topBatsman && topBatsman.runs >= 50 && !topBatsman.isOut) {
            points.push({
                matchId,
                category: 'milestone',
                priority: 9,
                headline: `${topBatsman.player.name} reaches fifty`,
                description: `Scored ${topBatsman.runs} runs off ${topBatsman.ballsFaced} balls at a strike rate of ${topBatsman.strikeRate?.toFixed(1)}`,
                playerId: topBatsman.playerId,
                overNumber,
                isAutoGenerated: true,
                autoGenReason: 'fifty_milestone',
            });
        }
        if (topBatsman && topBatsman.runs >= 100 && !topBatsman.isOut) {
            points.push({
                matchId,
                category: 'milestone',
                priority: 10,
                headline: `Century! ${topBatsman.player.name} reaches 100`,
                description: `Magnificent hundred off ${topBatsman.ballsFaced} balls`,
                playerId: topBatsman.playerId,
                overNumber,
                isAutoGenerated: true,
                autoGenReason: 'century_milestone',
            });
        }
        const expensiveBowler = innings.bowlingPerformances.find((b) => b.economyRate && b.economyRate > 12);
        if (expensiveBowler) {
            points.push({
                matchId,
                category: 'stat',
                priority: 7,
                headline: `${expensiveBowler.player.name} under pressure`,
                description: `Economy rate of ${expensiveBowler.economyRate?.toFixed(2)} in ${expensiveBowler.oversBowled} overs`,
                playerId: expensiveBowler.playerId,
                overNumber,
                isAutoGenerated: true,
                autoGenReason: 'high_economy',
            });
        }
        const topBowler = innings.bowlingPerformances[0];
        if (topBowler && topBowler.wickets >= 3) {
            points.push({
                matchId,
                category: 'stat',
                priority: 8,
                headline: `${topBowler.player.name} on fire`,
                description: `${topBowler.wickets} wickets for ${topBowler.runsConceded} runs`,
                playerId: topBowler.playerId,
                overNumber,
                isAutoGenerated: true,
                autoGenReason: 'wicket_haul',
            });
        }
        if (innings.inningsNumber === 2 && match.innings.length > 1) {
            const target = match.innings[0].totalRuns + 1;
            const remaining = target - innings.totalRuns;
            const ballsLeft = (20 * 6) - (innings.totalOvers * 6);
            const requiredRR = (remaining / ballsLeft) * 6;
            if (requiredRR > 12) {
                points.push({
                    matchId,
                    category: 'stat',
                    priority: 9,
                    headline: `Run rate pressure mounting`,
                    description: `Need ${remaining} runs from ${Math.floor(ballsLeft)} balls. Required RR: ${requiredRR.toFixed(2)}`,
                    overNumber,
                    isAutoGenerated: true,
                    autoGenReason: 'run_rate_pressure',
                });
            }
        }
        if (points.length > 0) {
            await database_1.default.talkingPoint.createMany({
                data: points,
                skipDuplicates: true,
            });
        }
        return await database_1.default.talkingPoint.findMany({
            where: { matchId, isUsed: false },
            orderBy: { priority: 'desc' },
            take: 10,
        });
    }
    async getTalkingPoints(matchId) {
        return await database_1.default.talkingPoint.findMany({
            where: { matchId, isUsed: false },
            orderBy: { priority: 'desc' },
        });
    }
    async markTalkingPointUsed(pointId) {
        return await database_1.default.talkingPoint.update({
            where: { id: pointId },
            data: { isUsed: true, usedAt: new Date() },
        });
    }
    detectProvider(url) {
        if (url.includes('youtube.com') || url.includes('youtu.be'))
            return 'youtube';
        if (url.includes('vimeo.com'))
            return 'vimeo';
        if (url.includes('s3.amazonaws.com') || url.includes('cloudfront.net'))
            return 's3';
        return 'custom';
    }
    extractVideoId(url) {
        const ytMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&]+)/);
        if (ytMatch)
            return ytMatch[1];
        const vimeoMatch = url.match(/vimeo\.com\/(\d+)/);
        if (vimeoMatch)
            return vimeoMatch[1];
        return undefined;
    }
    calculateTimestamp(overNumber, ballNumber) {
        const overTime = overNumber * 180;
        const ballTime = ballNumber * 30;
        return overTime + ballTime;
    }
    generatePodcastScript(match) {
        const script = `
Welcome to the cricket match recap.

Today's match: ${match.homeTeam.name} versus ${match.awayTeam.name} at ${match.venue}.
${match.tournament ? `This is part of the ${match.tournament.name}.` : ''}

${match.tossWinnerId ? `The toss was won by the team who chose to ${match.tossDecision}.` : ''}

First innings:
${match.innings[0] ? `The batting team scored ${match.innings[0].totalRuns} for ${match.innings[0].totalWickets} wickets in ${match.innings[0].totalOvers} overs.` : ''}
${match.innings[0]?.battingPerformances[0] ? `Top scorer was ${match.innings[0].battingPerformances[0].player.name} with ${match.innings[0].battingPerformances[0].runs} runs.` : ''}
${match.innings[0]?.bowlingPerformances[0] ? `Best bowling figures: ${match.innings[0].bowlingPerformances[0].player.name}, ${match.innings[0].bowlingPerformances[0].wickets} for ${match.innings[0].bowlingPerformances[0].runsConceded}.` : ''}

${match.innings[1] ? `
Second innings:
The chasing team managed ${match.innings[1].totalRuns} for ${match.innings[1].totalWickets} wickets.
${match.innings[1].battingPerformances[0] ? `${match.innings[1].battingPerformances[0].player.name} top-scored with ${match.innings[1].battingPerformances[0].runs} runs.` : ''}
` : ''}

Result: ${match.resultText || 'Match completed.'}
${match.manOfMatch ? `Man of the match: ${match.manOfMatch}` : ''}

Thank you for listening to this match recap.
    `.trim();
        return script;
    }
    generatePodcastSummary(match) {
        return `${match.homeTeam.name} vs ${match.awayTeam.name} at ${match.venue}. ${match.resultText}`;
    }
    generateKeyMoments(match) {
        const moments = [];
        moments.push({ time: 0, title: 'Introduction' });
        if (match.innings[0]) {
            moments.push({ time: 30, title: 'First Innings Summary' });
        }
        if (match.innings[1]) {
            moments.push({ time: 120, title: 'Second Innings Summary' });
        }
        moments.push({ time: 180, title: 'Match Result' });
        return moments;
    }
    generateChapters(match) {
        return [
            { time: 0, title: 'Introduction' },
            { time: 15, title: 'Toss and Team Selection' },
            { time: 30, title: 'First Innings' },
            { time: 120, title: 'Second Innings' },
            { time: 180, title: 'Result and Analysis' },
        ];
    }
}
exports.BroadcastService = BroadcastService;
exports.broadcastService = new BroadcastService();
//# sourceMappingURL=broadcast.service.js.map